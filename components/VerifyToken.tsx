"use client";
import { authenticator } from "otplib";
import { useContext, useState, useEffect } from "react";
import { SecretContext } from "./SecretStore";
import { Input, Notification, Text, Card } from "@mantine/core";

export const VerifyToken = () => {
  const { token } = useContext(SecretContext);
  const [inputToken, setInputToken] = useState<string>("");
  const [delta, setDelta] = useState<number | null>(null);
  const [notification, setNotification] = useState<string | null>(null);
  const [explanation, setExplanation] = useState<string>("");
  const [clientTimeReady, setClientTimeReady] = useState<boolean>(false); // Track if the client time is ready

  // Helper function to calculate the current time step and time window
  const getCurrentUnixTime = () => Math.floor(Date.now() / 1000);
  const getTimeWindow = () => Math.floor(getCurrentUnixTime() / 30);

  // Configure authenticator options for TOTP verification
  useEffect(() => {
    authenticator.options = {
      window: [2, 2], // Setting window range to allow for slight clock drift
    };
  }, []);

  // Function to update the explanation guide
  const updateExplanation = (inputToken: string, secret: string, delta: number | null) => {
    if (!clientTimeReady) return; // Avoid time-based calculations before client is ready

    const currentUnixTime = getCurrentUnixTime();
    const timeWindow = getTimeWindow();
    const algorithm = "HMAC-SHA1"; // default algorithm used by otplib

    if (inputToken.length < 6) {
      setExplanation("Type a 6-digit token generated based on the secret key and current time.");
      return;
    }

    if (delta === 0) {
      setExplanation(
        `The token you entered is valid for the current time window.\n\n
        Here's how the OTP was generated:\n
        first: : ${authenticator.options.createHmacKey}
        1. **Algorithm Used**: ${algorithm}\n
        2. **Current Unix Time**: ${currentUnixTime} (seconds since 1970)\n
        3. **Time Window**: floor(${currentUnixTime} / 30) = ${timeWindow}\n
        4. **Shared Secret Key**: The secret key is combined with the time window using the HMAC-SHA1 algorithm.\n
        5. **Final Step**: The result is truncated to produce a 6-digit code.\n\n
        This token matches the TOTP generated by combining the secret key with the current time.`
      );
    } else if (typeof delta === "number") {
      setExplanation(
        `The token is valid but not for the current time window. It was valid ${delta} window(s) away. This can happen due to clock drift or delays in entering the token.\n\n
        Here's how the OTP was generated:\n
        first: : ${authenticator.options.createHmacKey}
        1. **Algorithm Used**: ${algorithm}\n
        2. **Current Unix Time**: ${currentUnixTime} (seconds since 1970)\n
        3. **Time Window**: floor(${currentUnixTime} / 30) = ${timeWindow}\n
        4. **Shared Secret Key**: The secret key is combined with the time window using the HMAC-SHA1 algorithm.\n
        5. **Final Step**: The result is truncated to produce a 6-digit code.`
      );
    } else {
      setExplanation(
        `The token is invalid. Make sure you are using the correct secret key and that your device time is synchronized.\n\n
        Here's how the OTP should be generated:\n
        first: : ${authenticator.options.createHmacKey}
        1. **Algorithm Used**: ${algorithm}\n
        2. **Current Unix Time**: ${currentUnixTime} (seconds since 1970)\n
        3. **Time Window**: floor(${currentUnixTime} / 30) = ${timeWindow}\n
        4. **Shared Secret Key**: The secret key is combined with the time window using the HMAC-SHA1 algorithm.\n
        5. **Final Step**: The result is truncated to produce a 6-digit code.`
      );
    }
  };

  useEffect(() => {
    // Ensure that time-based content only renders after the component mounts
    setClientTimeReady(true);
  }, []);

  useEffect(() => {
    if (inputToken.length === 6 && clientTimeReady) {
      const deltaValue = authenticator.checkDelta(`${inputToken}`, token); // Check how many windows away the input token is
      const check = authenticator.verify({
        token: inputToken,
        secret: token,
      }); // Verify if the input token is exactly valid for the current window
      setDelta(deltaValue);

      // Set the notification message based on the delta value
      if (deltaValue === 0) {
        setNotification("The token is valid in the current window.");
      } else if (typeof deltaValue === "number") {
        setNotification(`The token was valid at ${deltaValue} window(s) away.`);
      } else {
        setNotification("The token is invalid.");
      }

      // Update the explanation guide
      updateExplanation(inputToken, token, deltaValue);
    } else {
      setNotification(null); // Clear notification if input is not complete
      setExplanation("Type a 6-digit token generated based on the secret key and current time.");
    }
  }, [inputToken, token, clientTimeReady]);

  return (
    <>
      {/* Instructional Card */}
      <Card shadow="sm" padding="lg" style={{ marginBottom: "1rem" }}>
        <Text w={500} size="lg" mb="sm">
          How TOTP Works
        </Text>
        <Text>
          TOTP (Time-based One-Time Password) is an algorithm that uses a shared secret key and the current time to generate a unique 6-digit token. This token is valid only for a short period, defined by a "window" of time.
        </Text>
        <Text mt="md">
          Enter the 6-digit token generated using your secret key below to verify its validity.
        </Text>
      </Card>

      {/* Input Field */}
      <Input
        onChange={(evt) => setInputToken(evt.target.value)}
        maxLength={6}
        value={inputToken}
        placeholder="000000"
        style={{ marginBottom: "1rem" }}
      />

      {/* Notification Message */}
      {notification && (
        <Notification
          color={delta === 0 ? "teal" : "red"}
          title="Token Validation"
          style={{ marginBottom: "1rem" }}
        >
          {notification}
        </Notification>
      )}

      {/* Dynamic Explanation Section */}
      <Card shadow="sm" padding="lg">
        <Text w={500} size="lg" mb="sm">
          Understanding the Result
        </Text>
        {/* Only render explanation after client-side hydration */}
        {clientTimeReady && <Text>{explanation}</Text>}
      </Card>
    </>
  );
};
